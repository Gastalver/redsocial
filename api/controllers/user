'use strict';
/**
 * Controlador de usuarios
 */
var bcrypt = require('bcrypt-nodejs'); // Para cifrar las contraseñas
var User = require('../models/user');
var Follow = require('../models/follow');
var jwt = require('../services/jwt');
require('mongoose-pagination');
var fs = require('fs'); // Para trabajar con ficheros.
var path = require('path'); // Para trabajar con rutas del sistema de ficheros

/**
 * Devuelve la página de inicio de la API
 * @param req
 * @param res
 */
function home(req,res){
    res.status(200).send(
        {
            message: 'Hola mundo'
        }
    )};

/**
 * Prueba de rutas
 * @param req
 * @param res
 */
function pruebas(req,res){
    res.status(200).send(
        {
            message: 'Acción de pruebas en el servidor de NodeJS'
        }
    )
}

/**
 * Crear nuevo usuario
 * @param req
 * @param res
 */
function saveUser(req,res){
    var params = req.body;
    var user = new User();
    if(params.name && params.surname &&
       params.nick && params.email && params.password){
        user.name = params.name,
        user.surname = params.surname,
        user.nick = params.nick.toLowerCase(),
        user.email = params.email.toLowerCase(),
        user.role = 'ROLE_USER',
        user.image = null;
        // Comprobar su el usuario o el nick ya existe
        User.find({$or: [
                {email: user.email.toLowerCase()},
                {nick: user.nick.toLowerCase()}
                ]}).exec((err,users)=>{
                    if(err) return res.status(500).send({message:'Error en la petición de usuarios'});
                    if(users && users.length >= 1){
                        return res.status(200).send({message:'El usuario que intentas registrar ya existe'});
                    } else {
                        //Cifrar password y guardar datos
                        bcrypt.hash(params.password,null,null,(err,hash)=>{
                            user.password = hash;
                            user.save((err,userStored)=>{
                                if(err) return res.status(500).send({message: 'Error al guardar el usuario'});
                                if (userStored){
                                    res.status(200).send({user: userStored});
                                } else {
                                    res.status(404).send({message: 'No se ha registrado el usuario'});
                                }
                            });
                        });
                    }

        });

   } else {
        res.status(200).send({
            message: '¡Envía todos los campos necesarios!'
        });
    }

};

/**
 * Login de un Usuario
 * @param req
 * @param res
 */
function loginUser(req,res){
    var params = req.body;
    var email = params.email;
    var password = params.password;
    User.findOne({email: email},(err,user)=>{
      if(err) return res.status(500).send({message:'Error en la petición'});
      if(user){
          bcrypt.compare(password,user.password,(err,check)=>{
              if(check){

                  if(params.gettoken){
                      //Generar y Devolver token
                      return res.status(200).send({
                          token: jwt.createToken(user)
                      });
                  } else {
                      //Devolver datos de usuario
                      user.password = undefined; // Truco para "eliminar esa propiedad del objeto antes de devolverlo"
                      return res.status(200).send({user})
                  }

              } else {
                  return res.status(404).send({message:'El usuario no se ha podido identificar'});
              }
          })
      } else {
          return res.status(404).send({message:'¡¡El usuario no se ha podido identificar!!'});
      }
    });
}

/**
 * Devuelve datos de usuario, si lo sigue el usuario logueado y si sigue a usuario logueado
 * @param req
 * @param res
 */
function getUser(req,res) {
    var userId = req.params.id;
    User.findById(userId, (err, user) => {
        if (err) return res.status(500).send({message: 'Error en la petición'});
        if (!user) return res.status(404).send({message: 'El usuario no existe'});

        followThisUser(req.user.sub, userId).then((value) => {
            console.log (value) ;
            return res.status(200).send({user, value});
        });
    });
}

/**
 * Devuelve si un usuario sigue a otro usuario y si este sigue a aquel.
 * @param identity_user_id
 * @param user_id
 * @returns {Promise<{following: *, followed: *}>}
 */
async function followThisUser(identity_user_id, user_id){
    var following = await Follow.findOne({"user": identity_user_id, "followed":user_id}).exec((err,follow)=>{
        if(err) return handleError(err); // Método dde Gestión errores node por consola.
        return follow;
    });

    var followed = await Follow.find({"user": user_id, "followed": identity_user_id}).exec((err,follow)=>{
        if(err) return handleError(err); // Método dde Gestión errores node por consola.
        return follow;
    });
    return {
        following: following,
        followed: followed
    }
}


/**
 * Devuelve un listado de usuarios paginado
 * @param req
 * @param res
 */
function getUsers(req,res){
    var identity_user_id = req.user.sub;
    var page = 1;
    if(req.params.page){
        page = req.params.page;
    }
    var itemsPerPage = 5;
    User.find().sort('_id').paginate(page,itemsPerPage,(err,users,total)=>{
        if(err) return res.status(500).send({message:'Error en la petición'});
        if(!users) return res.status(404).send({message: 'No hay usuarios disponibles'});
        return res.status(200).send({
            users,  // Es lo mismo que users:users
            total,  // Es lo mismo que total:total
            pages: Math.ceil((total/itemsPerPage))
        });
    });
}

/**
 * Actualizar datos de usuario
 * @param req
 * @param res
 */
function updateUsers(req,res){
    var userId = req.params.id;
    var update = req.body;
    // borramos la propiedad password
    delete update.password;
    if(userId != req.user.sub){
        return res.status(500).send({message:'No tienes permisos para actualizar los datos del usuario.'});
    }
    User.findByIdAndUpdate(userId, update,{new:true},(err,userUpdated)=>{
        if(err) return res.status(500).send({message:'Error en la petición.'});
        if(!userUpdated) return res.status(404).send({message:'No se ha podido actualizar el usuario.'});
        return res.status(200).send({user:userUpdated})
    })



}

/**
 * Subir archivos de imagen avatar de usuario
 * @param req
 * @param res
 * @returns {*}
 */
function uploadImage(req,res){
    var userId = req.params.id;

    if(req.files){
        // Extraemos la dirección donde va a ser alojado el archivo - generada por connect-multipart
        var file_path = req.files.image.path;
        // -> Algo así como /uploads/users/nombrearchivogeneradopormultilpart.jpg
        // Dividimos la URL por el carácter \ -con barra de escape- y obtenemos un array de las partes.
        var file_split = file_path.split('\\');
        // -> [uploads, users, nombrearchivogeneradopormultilpart.jpg]
        // Tomamos el nombre del archivo, que estará en la posición 2 del array (que empieza por 0)
        var file_name = file_split[2];
        // Extraer extensión del archivo con el mismo método.
        var ext_split = file_name.split('\.');
        var file_ext = ext_split[1];

        // Solo autorizamos la subida de imagenes del propio usuario
        if(userId != req.user.sub){
            return removeFilesOfUploads(res,file_path,'No tienes permisos para actualizar los datos del usuario.');
        }

        if (file_ext == 'png' || file_ext == 'jpg' || file_ext == 'jpeg' ||file_ext == 'gif'){
            // ACtualizamos documento de usuario logueado
            User.findByIdAndUpdate(userId,{image: file_name},{new:true},(err,userUpdated)=>{
                if(err) return res.status(500).send({message:'Error en la petición.'});
                if(!userUpdated) return res.status(404).send({message:'No se ha podido actualizar el usuario.'});
                return res.status(200).send({user:userUpdated})
            })
        }else{
            // Borramos el archivo (porque connect-multipart siempre lo guarda y no lo borra y devolvemos directamente un mensaje
            return removeFilesOfUploads(res,file_path,'Extensión no válida');
        }



    } else {
        return res.status(200).send({message:'No se han subido imágenes.'}); //TODO Comprobar que (if req.files) detecta si no se manda archivo.
    }
}

/**
 * Elimina archivo subido por connect-multipart al uploadDir con el que
 * se ha configurado este middleware (cfr. /api/routes/user.js) en este caso /uploads/users/nombrefichero
 */
function removeFilesOfUploads(res,file_path,message){
    fs.unlink(file_path, (err)=> {
        return res.status(200).send({message: message});  // TODO ¿Es adecuado devolver un codigo 200 siempre?
    });
}

function getImageFile(req,res){
    var image_file = req.params.imageFile;
    var path_file = './uploads/users/' + image_file;
    fs.exists(path_file,(exists)=>{
        if(exists){
            res.sendFile(path.resolve(path_file));
        } else {
            res.status(200).send({message:'No existe la imagen'});
        }
    })
}


module.exports = {
    home,
    pruebas,
    saveUser,
    loginUser,
    getUser,
    getUsers,
    updateUsers,
    uploadImage,
    getImageFile
}